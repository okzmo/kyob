// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

type Abilities string

const (
	AbilitiesADMIN             Abilities = "ADMIN"
	AbilitiesMANAGECHANNELS    Abilities = "MANAGE_CHANNELS"
	AbilitiesMANAGEROLES       Abilities = "MANAGE_ROLES"
	AbilitiesMANAGESERVER      Abilities = "MANAGE_SERVER"
	AbilitiesMANAGEEXPRESSIONS Abilities = "MANAGE_EXPRESSIONS"
	AbilitiesCHANGENICKNAME    Abilities = "CHANGE_NICKNAME"
	AbilitiesMANAGENICKNAMES   Abilities = "MANAGE_NICKNAMES"
	AbilitiesBAN               Abilities = "BAN"
	AbilitiesKICK              Abilities = "KICK"
	AbilitiesMUTE              Abilities = "MUTE"
	AbilitiesATTACHFILES       Abilities = "ATTACH_FILES"
	AbilitiesMANAGEMESSAGES    Abilities = "MANAGE_MESSAGES"
)

func (e *Abilities) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Abilities(s)
	case string:
		*e = Abilities(s)
	default:
		return fmt.Errorf("unsupported scan type for Abilities: %T", src)
	}
	return nil
}

type NullAbilities struct {
	Abilities Abilities `json:"abilities"`
	Valid     bool      `json:"valid"` // Valid is true if Abilities is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAbilities) Scan(value interface{}) error {
	if value == nil {
		ns.Abilities, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Abilities.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAbilities) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Abilities), nil
}

type ChannelType string

const (
	ChannelTypeVoice   ChannelType = "voice"
	ChannelTypeTextual ChannelType = "textual"
	ChannelTypeDm      ChannelType = "dm"
	ChannelTypeGroups  ChannelType = "groups"
)

func (e *ChannelType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ChannelType(s)
	case string:
		*e = ChannelType(s)
	default:
		return fmt.Errorf("unsupported scan type for ChannelType: %T", src)
	}
	return nil
}

type NullChannelType struct {
	ChannelType ChannelType `json:"channel_type"`
	Valid       bool        `json:"valid"` // Valid is true if ChannelType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChannelType) Scan(value interface{}) error {
	if value == nil {
		ns.ChannelType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ChannelType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChannelType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ChannelType), nil
}

type Channel struct {
	ID          string      `json:"id"`
	ServerID    string      `json:"server_id"`
	Name        string      `json:"name"`
	Type        ChannelType `json:"type"`
	Description pgtype.Text `json:"description"`
	Users       []string    `json:"users"`
	Roles       []string    `json:"roles"`
	X           int32       `json:"x"`
	Y           int32       `json:"y"`
	Active      bool        `json:"active"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
}

type Fact struct {
	ID        string      `json:"id"`
	UserID    string      `json:"user_id"`
	Icon      pgtype.Text `json:"icon"`
	Label     pgtype.Text `json:"label"`
	Value     pgtype.Text `json:"value"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

type Friend struct {
	ID        string    `json:"id"`
	UserID    string    `json:"user_id"`
	FriendID  string    `json:"friend_id"`
	Accepted  bool      `json:"accepted"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type Invite struct {
	ID       string    `json:"id"`
	ServerID string    `json:"server_id"`
	InviteID string    `json:"invite_id"`
	ExpireAt time.Time `json:"expire_at"`
}

type Link struct {
	ID        string      `json:"id"`
	UserID    string      `json:"user_id"`
	Label     pgtype.Text `json:"label"`
	Url       pgtype.Text `json:"url"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

type Message struct {
	ID               string    `json:"id"`
	AuthorID         string    `json:"author_id"`
	ServerID         string    `json:"server_id"`
	ChannelID        string    `json:"channel_id"`
	Content          []byte    `json:"content"`
	MentionsUsers    []string  `json:"mentions_users"`
	MentionsChannels []string  `json:"mentions_channels"`
	Attached         []string  `json:"attached"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

type Role struct {
	ID          string      `json:"id"`
	ServerID    string      `json:"server_id"`
	Name        string      `json:"name"`
	Color       string      `json:"color"`
	Description pgtype.Text `json:"description"`
	Abilities   []string    `json:"abilities"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
}

type Server struct {
	ID          string      `json:"id"`
	OwnerID     string      `json:"owner_id"`
	Name        string      `json:"name"`
	Avatar      pgtype.Text `json:"avatar"`
	Banner      pgtype.Text `json:"banner"`
	Description pgtype.Text `json:"description"`
	Private     bool        `json:"private"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
}

type ServerMembership struct {
	ID       string    `json:"id"`
	UserID   string    `json:"user_id"`
	ServerID string    `json:"server_id"`
	Roles    []string  `json:"roles"`
	X        int32     `json:"x"`
	Y        int32     `json:"y"`
	JoinedAt time.Time `json:"joined_at"`
}

type Token struct {
	ID       string    `json:"id"`
	UserID   string    `json:"user_id"`
	Token    string    `json:"token"`
	Type     string    `json:"type"`
	ExpireAt time.Time `json:"expire_at"`
}

type User struct {
	ID          string      `json:"id"`
	Email       string      `json:"email"`
	Username    string      `json:"username"`
	Password    string      `json:"password"`
	DisplayName string      `json:"display_name"`
	Avatar      pgtype.Text `json:"avatar"`
	Banner      pgtype.Text `json:"banner"`
	About       []byte      `json:"about"`
	MainColor   pgtype.Text `json:"main_color"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
}
