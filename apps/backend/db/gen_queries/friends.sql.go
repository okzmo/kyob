// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: friends.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptFriend = `-- name: AcceptFriend :exec
UPDATE friends SET accepted=true WHERE id=$1 AND user_id <> $2
`

type AcceptFriendParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) AcceptFriend(ctx context.Context, arg AcceptFriendParams) error {
	_, err := q.db.Exec(ctx, acceptFriend, arg.ID, arg.UserID)
	return err
}

const addFriend = `-- name: AddFriend :one
INSERT INTO friends (
  id, user_id, friend_id
) VALUES (
  $1, $2, $3
)
RETURNING id, user_id, friend_id, accepted, created_at, updated_at
`

type AddFriendParams struct {
	ID       string `json:"id"`
	UserID   string `json:"user_id"`
	FriendID string `json:"friend_id"`
}

func (q *Queries) AddFriend(ctx context.Context, arg AddFriendParams) (Friend, error) {
	row := q.db.QueryRow(ctx, addFriend, arg.ID, arg.UserID, arg.FriendID)
	var i Friend
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FriendID,
		&i.Accepted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFriend = `-- name: DeleteFriend :exec
DELETE FROM friends WHERE id=$1
`

func (q *Queries) DeleteFriend(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteFriend, id)
	return err
}

const getExistingChannel = `-- name: GetExistingChannel :one
UPDATE channels SET active = true
WHERE type = 'dm'
  AND array_length(users, 1) = 2
  AND $1::varchar = ANY(users) 
  AND $2::varchar = ANY(users)
RETURNING id, server_id, name, type, description, users, roles, x, y, active, created_at, updated_at
`

type GetExistingChannelParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

func (q *Queries) GetExistingChannel(ctx context.Context, arg GetExistingChannelParams) (Channel, error) {
	row := q.db.QueryRow(ctx, getExistingChannel, arg.Column1, arg.Column2)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.ServerID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Users,
		&i.Roles,
		&i.X,
		&i.Y,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFriends = `-- name: GetFriends :many
SELECT u.id, u.display_name, u.avatar, u.banner, u.about, f.accepted, f.id AS friendship_id, 
       f.user_id AS friendship_sender_id, c.id AS channel_id
FROM users u
INNER JOIN friends f ON u.id = f.friend_id
LEFT JOIN channels c ON $1::text = ANY(c.users) AND u.id::text = ANY(c.users)
WHERE f.user_id = $1

UNION

SELECT u.id, u.display_name, u.avatar, u.banner, u.about, f.accepted, f.id AS friendship_id, 
       f.user_id AS friendship_sender_id, c.id AS channel_id
FROM users u
INNER JOIN friends f ON u.id = f.user_id  
LEFT JOIN channels c ON $1 = ANY(c.users) AND u.id::text = ANY(c.users)
WHERE f.friend_id = $1
`

type GetFriendsRow struct {
	ID                 string      `json:"id"`
	DisplayName        string      `json:"display_name"`
	Avatar             pgtype.Text `json:"avatar"`
	Banner             pgtype.Text `json:"banner"`
	About              []byte      `json:"about"`
	Accepted           bool        `json:"accepted"`
	FriendshipID       string      `json:"friendship_id"`
	FriendshipSenderID string      `json:"friendship_sender_id"`
	ChannelID          pgtype.Text `json:"channel_id"`
}

func (q *Queries) GetFriends(ctx context.Context, dollar_1 string) ([]GetFriendsRow, error) {
	rows, err := q.db.Query(ctx, getFriends, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendsRow
	for rows.Next() {
		var i GetFriendsRow
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.Avatar,
			&i.Banner,
			&i.About,
			&i.Accepted,
			&i.FriendshipID,
			&i.FriendshipSenderID,
			&i.ChannelID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
